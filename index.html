<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Namrutha JD - Data Structures & Algorithms Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Soft blue background */
            color: #333;
            line-height: 1.6;
            font-size: 16px;
        }

        header {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #1976d2, #90caf9); /* Gradient shades of blue */
            color: white;
            text-align: center;
            padding: 50px 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            animation: bounce 1.5s infinite alternate;
        }

        header p {
            font-size: 1.2em;
        }

        .bubble, .flower {
            position: absolute;
            animation: move 10s infinite;
        }

        .bubble {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(2px);
        }

        .flower {
            width: 40px;
            height: 40px;
            background-color: #42a5f5; /* Blue flower */
            border-radius: 50%;
            filter: blur(1px);
            animation-duration: 12s;
        }

        nav {
            background-color: #64b5f6; /* Soft blue nav bar */
            text-align: center;
            padding: 15px 0;
            animation: slideIn 1s ease-out;
        }

        nav a {
            color: white;
            text-decoration: none;
            margin: 0 20px;
            font-size: 1.1em;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        nav a:hover {
            background-color: #1976d2; /* Darker blue on hover */
            color: white;
        }

        #top-images, #project-image {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        #top-images img, #project-image img {
            max-width: 100%;
            height: auto;
            margin: 10px;
        }

        #about, #project-details {
            padding: 60px 20px;
            text-align: center;
            background-color: #fff;
            margin: 40px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            animation: fadeIn 2s ease-in;
        }

        #about p, #project-details p {
            font-size: 1.1em;
            color: #555;
        }

        footer {
            background-color: #0d47a1; /* Deep blue footer */
            color: white;
            padding: 20px;
            text-align: center;
        }

        /* Keyframes and animations unchanged */
    </style>
</head>
<body>
    <header>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>

        <div class="flower"></div>
        <div class="flower"></div>
        <div class="flower"></div>
        <div class="flower"></div>
        <div class="flower"></div>
        <div class="flower"></div>
        <div class="flower"></div>

        <h1>Namrutha JD - Data Structures & Algorithms Portfolio</h1>
        <p>Explore the Various Projects I've Worked On</p>
    </header>

    <nav>
        <a href="#about">About Me</a>
        <a href="#project-details">Course Projects</a>
        <a href="learning-reflection.html">Learning Reflections</a>
        <a href="student-details.html">Student Details</a>
    </nav>

    <section id="top-images">
        <img src="https://raw.githubusercontent.com/akgmage/go-web/master/templates/assets/DSA.png" alt="DSA Image">
    </section>

    <section id="about">
        <h2>About Me</h2>
        <p>Hi, I'm Namrutha, a computer science student with a deep passion for solving complex problems and exploring innovative solutions. I specialize in Design and Analysis of Algorithms and aim to master efficient coding practices to contribute to cutting-edge technologies and impactful software development. Throughout my journey, I have gained extensive experience with various algorithms and data structures, including arrays, linked lists, trees, sorting techniques, string matching, and searching algorithms.</p>
    </section>

    <section id="project-details">
        <h1>DESIGN AND ANALYSIS OF ALGORITHMS </h1>

    <div class="section">
        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> In computer programs, where the same task repeats over and over.</li>
            <li><strong>Recursion:</strong> The way trees branch out or rivers split into smaller streams. This is similar to recursion, where a problem is broken into smaller, repeating parts.</li>
            <li><strong>Backtracking:</strong> Picture ants searching for food. They try different paths, and if one doesn’t work, they go back and try another. This is backtracking, where you explore different options and go back if needed.</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. Space and Time Efficiency</h2>
        <ul>
            <li><strong>Space Efficiency:</strong> This refers to how much memory the program uses. Using too much memory can slow things down or cause problems.</li>
            <li><strong>Time Efficiency:</strong> This is about how fast a program runs. If a program is slow, it might not work well, especially with lots of data.</li>
            <li><strong>Why It Matters:</strong> Efficient use of memory and time helps programs handle larger tasks without slowing down or using too many resources. For example, when you're using an app that shows live updates (like sports scores), you want it to load quickly without crashing.</li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Tree Data Structures</h2>
        <ul>
            <li><strong>Binary Search Tree (BST):</strong> Imagine a phone book where names are sorted in order. You can quickly find any name, but if the book becomes unbalanced (like a straight list), it becomes slower.</li>
            <li><strong>2-3 Tree:</strong> This is a more balanced tree that helps keep things organized and fast.</li>
            <li><strong>AVL Tree:</strong> This tree keeps itself balanced by adjusting when necessary, though it’s a bit more complex.</li>
            <li><strong>Red-Black Tree:</strong> This is another balanced tree that requires fewer adjustments, making it easier to maintain.</li>
            <li><strong>Heap:</strong> A heap is like a to-do list where the most important task is always on top, making it easier to find.</li>
            <li><strong>Trie:</strong> This is a tree used to store strings (like words), which makes it very fast for searching.</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. Array Query Algorithms</h2>
        <ul>
            <li><strong>Segment Trees:</strong> These help answer questions about parts of an array very quickly, even if the array changes often.</li>
            <li><strong>Fenwick Trees:</strong> A simpler version of segment trees, great for quick range queries with less memory.</li>
            <li><strong>Sparse Tables:</strong> These allow extremely fast queries after a one-time setup, perfect for certain problems.</li>
        </ul>
    </div>

    <div class="section">
        <h2>5. Trees vs. Graphs</h2>
        <ul>
            <li><strong>Trees:</strong> These are simple structures with no loops, like a family tree or an organization chart.</li>
            <li><strong>Graphs:</strong> These are more flexible, allowing loops and many connections, like a map of cities connected by roads.</li>
            <li><strong>When to Use:</strong> Trees are used for things like file systems (folders inside folders) and decision-making. Graphs are used for things like GPS navigation and social networks.</li>
        </ul>
    </div>

    <div class="section">
        <h2>6. Sorting and Searching Algorithms</h2>
        <h3>Sorting Algorithms</h3>
        <ul>
            <li><strong>Bubble Sort:</strong> Compares adjacent items and swaps them if they’re in the wrong order. It’s simple but slow for large data.</li>
            <li><strong>Selection Sort:</strong> Finds the smallest (or largest) item and places it in the right spot. Still slow for large data.</li>
            <li><strong>Insertion Sort:</strong> Builds the sorted list one item at a time. It’s faster if the list is already mostly sorted.</li>
            <li><strong>Merge Sort:</strong> Divides the list in half, sorts both parts, and then merges them. It’s more efficient for large data.</li>
            <li><strong>Quick Sort:</strong> Picks a “pivot” and divides the list into smaller parts, then sorts them. It’s fast most of the time but can slow down with bad data.</li>
            <li><strong>Heap Sort:</strong> Uses a heap to sort data. It’s efficient but not as fast as Merge or Quick Sort.</li>
        </ul>

        <h3>Searching Algorithms</h3>
        <ul>
            <li><strong>Boyer-Moore:</strong> Searches for patterns in text quickly by skipping parts that don’t match.</li>
            <li><strong>Knuth-Morris-Pratt (KMP):</strong> Uses a clever trick to avoid re-checking parts of text, making it faster.</li>
            <li><strong>Rabin-Karp:</strong> Uses a “rolling” hash to quickly search for patterns.</li>
        </ul>

        <h3>Graph Search Algorithms</h3>
        <ul>
            <li><strong>Dijkstra’s Algorithm:</strong> Finds the shortest path between two points in a network, like finding the shortest driving route between cities.</li>
            <li><strong>Kruskal’s Algorithm:</strong> Finds the cheapest way to connect all points in a network, like laying roads between cities with the least cost.</li>
            <li><strong>Prim’s Algorithm:</strong> Builds a network by adding the cheapest connections one at a time.</li>
            <li><strong>Floyd-Warshall Algorithm:</strong> Finds the shortest paths between all pairs of points in a network, useful in things like transportation systems.</li>
        </ul>
    </div>
    </section>

    <footer>
        <p>&copy; 2024 Namrutha JD - All Rights Reserved</p>
    </footer>
</body>
</html>
